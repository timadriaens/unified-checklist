[
["index.html", "National, unified checklist of alien species in Belgium 1 Intro", " National, unified checklist of alien species in Belgium Peter Desmet, Damiano Oldoni 2019-01-18 1 Intro This document contains and describes all the steps in creating a unified checklist of alien species in Belgium and was developed for the Tracking Invasive Alien Species (TrIAS) project. By running this document in R, it will create all the necessary data files for the unified checklist. Load libraries: library(tidyverse) # To do data science library(magrittr) # To use %&lt;&gt;% pipes library(here) # To find files library(janitor) # To clean input data library(digest) # To generate hashes library(rgbif) # To use GBIF services # devtools::install_github(&quot;trias-project/trias&quot;) library(trias) # To use functions developed for TrIAS "],
["1_get_taxa.html", "2 Get taxa from checklists 2.1 Choose checklists 2.2 Get taxa 2.3 Filter on distribution 2.4 Get GBIF backbone taxonomy information 2.5 Show summary and save", " 2 Get taxa from checklists In this chapter we select species checklists and retrieve the taxa they contain. 2.1 Choose checklists The unified checklist is compiled from species checklists published to GBIF under the TrIAS project. Here we choose the checklists we want to include and rank them by trust (most trustworthy first). The ranking will help to choose between duplicate taxa in later steps. Choose checklists: checklist_keys &lt;- c( &quot;9ff7d317-609b-4c08-bd86-3bc404b77c42&quot;, # alien-plants-belgium &quot;289244ee-e1c1-49aa-b2d7-d379391ce265&quot;, # alien-macroinvertebrates &quot;98940a79-2bf1-46e6-afd6-ba2e85a26f9f&quot;, # alien-fishes-checklist &quot;b043c480-dd36-4f4f-aa82-e188753ff09d&quot;, # uredinales-belgium-checklist &quot;1f3505cd-5d98-4e23-bd3b-ffe59d05d7c2&quot;, # ad-hoc-checklist &quot;1738f272-6b5d-4f43-9a92-453a8c5ea50a&quot;, # rinse-pathways-checklist &quot;3f5e930b-52a5-461d-87ec-26ecd66f14a3&quot; # rinse-registry-checklist ) Get metadata for these checklists from GBIF and display the result: Save to CSV. 2.2 Get taxa Get taxa from these checklists from GBIF. Note: here we get checklist taxa, not GBIF backbone taxa. Select columns of interest, rename key to taxonKey and sort by taxonKey. Convert the column issues from a list to a concatenated string. Preview checklist taxa: 2.3 Filter on distribution TrIAS checklists can contain more than alien species in Belgium. We therefore need to filter on the associated distribution information (using the trias::has_distribution() function) as follows: In Belgium: country(code) = BE Present: occurrenceStatus status = PRESENT, COMMMON, RARE OR IRREGULAR Introduced: establishmentMeans = INTRODUCED, NATURALISED, INVASIVE OR ASSISTED COLONISATION Note: we filter on distribution information of checklist taxa, not GBIF backbone taxa. That is because backbone taxa contain distribution information from TrIAS checklists and other checklists, which we don’t want to consider here. E.g. compare: Distributions for checklist taxon Eriocheir sinensis (140563012) Distributions for backbone taxon Eriocheir sinensis (2225776) Note: if a checklist has related information for a taxon, but not a valid distribution, that related information will NOT be included in the unified checklist. This is to exclude related information about a taxon for which the checklist did not even consider a Belgian scope (e.g. pathway). Get distribution information from GBIF and check if these meet the filter criteria. The result (TRUE/FALSE) is inserted as an extra column validDistribution. Preview some taxa with not a single valid distribution (taxonKey can be used to verify manually on GBIF): Rename nubKey to bb_key and move to the end. 2.4 Get GBIF backbone taxonomy information A taxon can occur on more than one checklist. To identify these duplicates, we cannot rely on the scientific name as there might be spelling variations (e.g. with or without authorship) and it does not account for synonyms that should be lumped with the accepted taxon. To have unifying taxon identifiers across taxa, we rely on the GBIF backbone taxonomy, to which every checklist taxon (re)published to GBIF is automatically matched. If a match in the backbone is found, the checklist taxon will have a nubKey. Filter taxa on having valid distribution and nubKey and create vector of unique nubKeys. Get GBIF backbone taxonomy information. Rename accepted to acceptedName. Add prefix bb_ to column names. Select columns of interest. Join backbone information with checklist taxa. Note: this can attach information to taxa with validDistribution = FALSE that share a bb_key with other taxa. Preview merged information: 2.5 Show summary and save Show summary per checklist: Save to two CSVs: data/raw/taxa.csv: all checklist taxa data/interim/taxa_with_verification.csv: subset of checklist taxa with a valid distribution and an empty column verificationKey. This file will be used in later steps. "],
["2_get_information.html", "3 Get related information 3.1 Read taxa 3.2 Get distributions 3.3 Get species profiles 3.4 Get descriptions", " 3 Get related information In this chapter we retrieve related information for taxa on the checklists (with a valid distribution). 3.1 Read taxa Read taxa from data/interim/taxa_with_verification.csv. Extract taxonKeys as a vector. 3.2 Get distributions Get distributions for our taxa from GBIF. Save to CSV. 3.3 Get species profiles Get species profiles for our taxa from GBIF. Save to CSV. 3.4 Get descriptions Get descriptions for our taxa from GBIF. Save to CSV. "],
["3_verify_taxa.html", "4 Verify taxa 4.1 Read taxa 4.2 Read verification information 4.3 Run and save verification 4.4 Show verification status", " 4 Verify taxa In this chapter we verify taxonomic information returned by the GBIF Backbone Taxonomy. We do this because we want to use the backbone information to unify taxa that can be considered the same within or across checklists. This is straightforward for (accepted) taxa with the same backbone key (bb_key), but requires verification for taxa the backbone does not recognize (no backbone match) or will lump under another name (synonyms). See 4.2. 4.1 Read taxa Read taxa from data/interim/taxa_with_verification.csv. 4.2 Read verification information Verification information consists of a manually assigned verificationKey for taxa the backbone does not recognize (no backbone match) or will lump under another name (synonyms). Those checklist/backbone/accepted taxon combinations are stored in data/interim/verification.tsv, which was created/updated in previous runs of this chapter and then manually annoted with a verificationKey. 4.3 Run and save verification Use the existing verification information to verify taxa with the function trias::verify_taxa: verification &lt;- trias::verify_taxa(taxa, verification) Note: to start a verification from scratch, use trias::verify_taxa(taxa). Save taxa with populated verificationKey back to data/interim/taxa_with_verification.csv. Save updated verification back to data/interim/verification.tsv (sorted on scientificName) 4.4 Show verification status 4.4.1 Unmatched taxa Status Number of taxa Verified 0 Unverified 114 New in this run 0 No longer used 0 Unmatched taxa are those for which the automatic backbone matching on the scientific name failed (have BACKBONE_MATCH_NONE in issues), either because the scientific name could not be parsed or because it is not listed in the backbone. Verification (see 4.2) involves setting the verificationKey to a manually found bb_key. One could even set multiple bb_keys, e.g. to split a hybrid formula into its hybrid parents. 4.4.2 Synonyms Status Number of taxa Previously verified 153 Unverified 832 New in this run 0 No longer used 0 Synonyms are taxa that the backbone will lump under an accepted taxon (taxonomicStatus = SYNONYM or similar). This lumping is often correct, but should be verified. Verification (see 4.2) involves setting the verifiedKey to one of the following: accepted bb_key suggested by GBIF: backbone synonymy is accepted and taxon will be lumped. another accepted bb_key: backbone synonymy is rejected, but taxon will be lumped under another name. bb_key of taxon itself: backbone synonymy is rejected, taxon will be considered as separate taxon. 4.4.3 Accepted taxa Status Number of taxa Verified (automatic) 5008 Unverified 0 Accepted taxa are those the backbone considers own entities (taxonomicStatus = ACCEPTED or DOUBTFUL) that won’t be lumped. No verification is required for these: verificationKey is automatically set to their bb_key. 4.4.4 Erroneous verificationKeys Provided verification keys that are not found in the GBIF backbone: 4.4.5 Additional information Additional information regarding the verification information that is of no further consequence. Duplicate taxa (having same bb_key and bb_acceptedKey) that are quick wins to verify: Previously listed synonyms for which the scientific name was updated in the backbone: Previously listed synonyms for which the accepted scientific name was updated in the backbone: "],
["4_unify_taxa.html", "5 Unify taxa 5.1 Read taxa 5.2 Unify taxa 5.3 Get GBIF backbone taxonomy information", " 5 Unify taxa In this chapter we unify taxa on their verificationKey. 5.1 Read taxa Read taxa from data/interim/taxa_with_verification.csv. 5.2 Unify taxa Remove taxa without verificationKey. Separate multiple verificationKeys (if any) for single taxa. Group taxa by verificationKey (saving sourceChecklists and sourceTaxa bundled per key). Extract verificationKey as a vector. Number of unique taxa: 3502 5.3 Get GBIF backbone taxonomy information Even though we stored some backbone information for most of our taxa in the previous steps, we want to start from scratch here and retrieve it from GBIF again, as 1) some taxon keys in verificationKeys will be new and 2) we want to store more attributes per taxon this time. Get GBIF backbone taxonomy information. Rename accepted to acceptedName. Select columns of interest. Join backbone information with our unified taxa, so we keep sourceChecklists and sourceTaxa. Move columns sourceChecklists and sourceTaxa to the end. Preview merged information: Number of taxa: 3502 Save to CSV. "],
["5_unify_information.html", "6 Unify related information 6.1 Read data 6.2 Assign checklist order 6.3 Unify distribution 6.4 Unify species profiles 6.5 Unify descriptions", " 6 Unify related information In this chapter we unify related information for each verified taxon. 6.1 Read data checklists &lt;- read_csv(here(&quot;data&quot;, &quot;raw&quot;, &quot;checklists.csv&quot;)) taxa &lt;- read_csv(here(&quot;data&quot;, &quot;interim&quot;, &quot;taxa_with_verification.csv&quot;)) distributions &lt;- read_csv(here(&quot;data&quot;, &quot;raw&quot;, &quot;distributions.csv&quot;)) speciesprofiles &lt;- read_csv(here(&quot;data&quot;, &quot;raw&quot;, &quot;speciesprofiles.csv&quot;)) descriptions &lt;- read_csv(here(&quot;data&quot;, &quot;raw&quot;, &quot;descriptions.csv&quot;)) 6.2 Assign checklist order Get checklist keys as (ordered) vector. Assign the checklist order (= index of checklist keys) as an extra column to taxa. 6.3 Unify distribution Parse temporal (eventDate) information. distributions_unified &lt;- distributions %&gt;% # Split temporal on &quot;/&quot; into startYear and endYear # If temporal only contains a single year, then endYear will be empty separate( temporal, into = c(&quot;startYear&quot;, &quot;endYear&quot;), sep = &quot;/&quot;, remove = FALSE, convert = TRUE, extra = &quot;drop&quot;, fill = &quot;right&quot; ) %&gt;% # Only keep the first 4 characters: 1968-11-21 -&gt; 1968 mutate( startYear = as.integer(str_sub(startYear, 1, 4)), endYear = as.integer(str_sub(endYear, 1, 4)) ) %&gt;% # If endYear is empty (no range), populate it with startYear: 2018 &amp; 2018 mutate(endYear = if_else(is.na(endYear), startYear, endYear)) Filter distributions. distributions_unified &lt;- distributions_unified %&gt;% # Filter on non-native species present in (at least part of) Belgium filter( country == &quot;BE&quot; &amp; establishmentMeans %in% c(&quot;INTRODUCED&quot;, &quot;NATURALISED&quot;, &quot;INVASIVE&quot;, &quot;ASSISTED COLONISATION&quot;) &amp; status %in% c(&quot;PRESENT&quot;, &quot;COMMON&quot;, &quot;RARE&quot;, &quot;IRREGULAR&quot;) ) Choose a single distribution within a checklist. distributions_unified &lt;- distributions_unified %&gt;% # Join distribution with taxon to get verificationKey and checklistOrder left_join(taxa, by = &quot;taxonKey&quot;) %&gt;% # Remove records that have no verificationKey (e.g. one wasn&#39;t assigned yet) filter(!is.na(verificationKey)) %&gt;% # Group by verificationKey within checklist group_by( datasetKey, checklistOrder, verificationKey ) %&gt;% # Take earliest year, latest year and note taxonIDs summarize( startYear = as.integer(min(startYear, na.rm = TRUE)), endYear = as.integer(max(endYear, na.rm = TRUE)), sourceTaxa = paste(sort(unique(taxonKey)), collapse = &quot;,&quot;) ) Choose a single distribution across checklists. distributions_unified &lt;- distributions_unified %&gt;% # Sort by checklist order (trustworthiness) arrange(checklistOrder) %&gt;% # Group by verificationKey across checklists group_by(verificationKey) %&gt;% # Select year of most trustworthy checklist (first one) # and note that checklist and its taxonKey(s) summarize( startYear = first(startYear), endYear = first(endYear), sourceChecklist = first(datasetKey), sourceTaxa = first(sourceTaxa) ) %&gt;% # Sort by verificationKey arrange(verificationKey) Save to CSV. 6.4 Unify species profiles Filter species profiles. speciesprofiles_unified &lt;- speciesprofiles %&gt;% # Remove species profiles that contain NA for any of the attributes # This is rare: normally all attributes are populated or there just isn&#39;t a # species profile for that species filter( !is.na(marine) &amp; !is.na(freshwater) &amp; !is.na(terrestrial) ) Choose a single species profile within a checklist. speciesprofiles_unified &lt;- speciesprofiles_unified %&gt;% # Join species profile with taxon to get verificationKey and checklist order left_join(taxa, on = taxonID) %&gt;% # Remove records that have no verificationKey (e.g. one wasn&#39;t assigned yet) filter(!is.na(verificationKey)) %&gt;% # Group by verificationKey within checklist group_by( datasetKey, checklistOrder, verificationKey ) %&gt;% # Take first species profile and note taxonKey summarize( marine = first(marine), freshwater = first(freshwater), terrestrial = first(terrestrial), sourceTaxon = first(taxonKey) ) Choose a single species profile across checklists. speciesprofiles_unified &lt;- speciesprofiles_unified %&gt;% # Sort by checklist order (trustworthiness) arrange(checklistOrder) %&gt;% # Group by verificationKey across checklists group_by(verificationKey) %&gt;% # Select species profile of most trustworthy checklist (first one) # and note that checklist and its taxonID summarize( marine = first(marine), freshwater = first(freshwater), terrestrial = first(terrestrial), sourceChecklist = first(datasetKey), sourceTaxon = first(sourceTaxon) ) %&gt;% # Sort by verificationKey arrange(verificationKey) Save to CSV. 6.5 Unify descriptions Filter non NA descriptions. Select unique descriptions (within their type) within a checklist. descriptions_unified &lt;- descriptions_unified %&gt;% # Join species profile with taxon to get verificationKey and checklist order left_join(taxa, on = taxonKey) %&gt;% # Remove records that have no verificationKey (e.g. one wasn&#39;t assigned yet) filter(!is.na(verificationKey)) %&gt;% # Group by type and verificationKey within checklist group_by( datasetKey, checklistOrder, verificationKey, type ) %&gt;% # Choose distinct value for that type and verificationKey # If identical values exist within that grouping, distinct() will take # most trustworthy (first one) # Note: since we use distinct we can&#39;t keep a sourceTaxon (taxonKey) distinct( description ) Select unique descriptions (within their type) across checklists. descriptions_unified &lt;- descriptions_unified %&gt;% # Sort by checklist order (trustworthiness) arrange(checklistOrder) %&gt;% # Group by type and verificationKey across checklists group_by( type, verificationKey ) %&gt;% # Choose distinct value for that type and verificationKey distinct( description, .keep_all = TRUE ) %&gt;% # Move verificationKey to beginning and drop checklist_order select(verificationKey, everything(), -checklistOrder) %&gt;% # Rename checklist rename(sourceChecklist = datasetKey) %&gt;% # Sort by verificationKey and type arrange(verificationKey, type) Save to CSV. "],
["dwc_mapping.html", "7 Darwin Core mapping 7.1 Read data 7.2 Process data 7.3 Preview data 7.4 Taxon core 7.5 Literature reference extension 7.6 Distribution extension 7.7 Description extension", " 7 Darwin Core mapping 7.1 Read data checklists &lt;- read_csv(here(&quot;data&quot;, &quot;raw&quot;, &quot;checklists.csv&quot;)) input_taxa &lt;- read_csv(here(&quot;data&quot;, &quot;interim&quot;, &quot;taxa_unified.csv&quot;)) input_distributions &lt;- read_csv(here(&quot;data&quot;, &quot;interim&quot;, &quot;distributions_unified.csv&quot;)) input_speciesprofiles &lt;- read_csv(here(&quot;data&quot;, &quot;interim&quot;, &quot;speciesprofiles_unified.csv&quot;)) input_descriptions &lt;- read_csv(here(&quot;data&quot;, &quot;interim&quot;, &quot;descriptions_unified.csv&quot;)) 7.2 Process data Add prefix input_ to all column names to avoid name clashes with Darwin Core terms: colnames(input_taxa) &lt;- paste0(&quot;input_&quot;, colnames(input_taxa)) colnames(input_distributions) &lt;- paste0(&quot;input_&quot;, colnames(input_distributions)) colnames(input_speciesprofiles) &lt;- paste0(&quot;input_&quot;, colnames(input_speciesprofiles)) colnames(input_descriptions) &lt;- paste0(&quot;input_&quot;, colnames(input_descriptions)) 7.3 Preview data Number of rows: Taxa: 3502 Distributions: 3502 Species profiles: 3489 Descriptions: 8834 Number of taxa per kingdom and rank: Number of taxa and descriptions per type: 7.4 Taxon core 7.4.1 Pre-processing Create a dataframe from the source taxa: taxon &lt;- input_taxa Separate input_canonicalName in 3 parts: taxon %&lt;&gt;% separate( input_canonicalName, into = c( &quot;input_canonicalName_genus&quot;, &quot;input_canonicalName_species&quot;, &quot;input_canonicalName_infraspecific&quot; ), sep = &quot;\\\\s+&quot;, remove = FALSE, convert = TRUE, extra = &quot;drop&quot;, fill = &quot;right&quot; ) Merge data with 7.4.2 Term mapping Map the data to Darwin Core Taxon. 7.4.2.1 language taxon %&lt;&gt;% mutate(language = &quot;en&quot;) 7.4.2.2 license # TODO: Taxa info comes from backbone (CC-BY), rest from datasets # (might not always be CC0) taxon %&lt;&gt;% mutate(license = &quot;http://creativecommons.org/publicdomain/zero/1.0/&quot;) 7.4.2.3 rightsHolder # TODO: Could be publisher of this dataset (INBO), publisher of taxa (GBIF) # or publishers of info (checklist datasets) taxon %&lt;&gt;% mutate(rightsHolder = &quot;Public Domain Dedication&quot;) 7.4.2.4 accessRights # TODO: Depends on rightsHolder 7.4.2.5 datasetID taxon %&lt;&gt;% mutate(datasetID = &quot;&quot;) 7.4.2.6 institutionCode taxon %&lt;&gt;% mutate(institutionCode = &quot;INBO&quot;) 7.4.2.7 datasetName taxon %&lt;&gt;% mutate(datasetName = &quot;Unified checklist of alien species in Belgium&quot;) 7.4.2.8 references taxon %&lt;&gt;% mutate(references = paste0(&quot;https://www.gbif.org/species/&quot;, input_verificationKey)) 7.4.2.9 taxonID # TODO: Could also be gbif:input_verificationKey taxon %&lt;&gt;% mutate(taxonID = paste0(&quot;https://www.gbif.org/species/&quot;, input_verificationKey)) 7.4.2.10 scientificName taxon %&lt;&gt;% mutate(scientificName = input_scientificName) 7.4.2.11 kingdom taxon %&lt;&gt;% mutate(kingdom = input_kingdom) 7.4.2.12 phylum taxon %&lt;&gt;% mutate(phylum = input_phylum) 7.4.2.13 class taxon %&lt;&gt;% mutate(phylum = input_class) 7.4.2.14 order taxon %&lt;&gt;% mutate(order = input_order) 7.4.2.15 family taxon %&lt;&gt;% mutate(family = input_family) 7.4.2.16 genus Inspect differences between input_genus and input_canonicalName_genus: taxon %&gt;% filter(input_genus != input_canonicalName_genus) %&gt;% select(input_verificationKey, input_scientificName, input_genus, input_canonicalName_genus, input_taxonomicStatus) The input_genus under which the GBIF Backbone Taxonomy has classified a taxon can differ from the genus in the scientific name. Since we consider all our taxa as accepted taxa, we take the genus from the scientific name (= input_canonicalName_genus). taxon %&lt;&gt;% mutate(genus = input_canonicalName_genus) 7.4.2.17 specificEpithet taxon %&lt;&gt;% mutate(specificEpithet = input_canonicalName_species) 7.4.2.18 infraspecificEpithet taxon %&lt;&gt;% mutate(infraspecificEpithet = input_canonicalName_infraspecific) 7.4.2.19 taxonRank Inspect values: taxon %&gt;% group_by(input_rank) %&gt;% count() Map values to lowercase: taxon %&lt;&gt;% mutate(taxonRank = str_to_lower(input_rank)) 7.4.2.20 scientificNameAuthorship taxon %&lt;&gt;% mutate(scientificNameAuthorship = input_authorship) 7.4.2.21 taxonRemarks # TODO: This taxon bundles data from checklists and taxa? 7.4.3 Post-processing Remove the original columns: taxon %&lt;&gt;% select(-starts_with(&quot;input_&quot;)) Preview data: taxon %&gt;% head() Save to CSV: write_csv(taxon, here(&quot;data&quot;, &quot;processed&quot;, &quot;taxon.csv&quot;), na = &quot;&quot;) 7.5 Literature reference extension TODO: this looks like the best way to capture the checklists that contributed to the information unified here. Note, to know actual contribution, it is best to join distributions, descriptions and speciesProfiles and get sourceChecklist rather than using sourceChecklists in taxa. 7.5.1 Pre-processing … Map the data to Literature References. 7.5.2 Term mapping 7.5.2.1 identifier # TODO: DOI of sourceChecklist (is internal identifier) 7.5.2.2 bibliographicCitation # TODO: See checklist metadata from GBIF 7.5.2.3 Date # TODO: Last publication date 7.5.2.4 Subject # TODO: concatenated list with: &quot;distribution, speciesProfile, description&quot; 7.5.2.5 DatasetID # TODO: maybe repeat DOI here?? 7.5.3 Post-processing … 7.6 Distribution extension 7.6.1 Pre-processing Create a dataframe with all data: distribution &lt;- input_distributions Map the data to Species Distribution. 7.6.2 Term mapping … 7.6.3 Post-processing … 7.7 Description extension 7.7.1 Pre-processing … Map the data to … 7.7.2 Term mapping … 7.7.3 Post-processing … "]
]
