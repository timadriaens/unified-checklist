# Darwin Core mapping

In this chapter we standardize the unified information to a Darwin Core checklist that can be harvested by GBIF.

```{r}
knitr::opts_chunk$set(echo = TRUE) # Include code chunks for this document
```

## Read unified data

```{r}
checklists <- read_csv(here("data", "raw", "checklists.csv"))
input_taxa <- read_csv(here("data", "interim", "taxa_unified.csv"))
input_distributions <- read_csv(here("data", "interim", "distributions_unified.csv"))
input_speciesprofiles <- read_csv(here("data", "interim", "speciesprofiles_unified.csv"))
input_descriptions <- read_csv(here("data", "interim", "descriptions_unified.csv"))
```

## Process data

Add prefix `input_` to all column names to avoid name clashes with Darwin Core terms:

```{r}
colnames(input_taxa) <- paste0("input_", colnames(input_taxa))
colnames(input_distributions) <- paste0("input_", colnames(input_distributions))
colnames(input_speciesprofiles) <- paste0("input_", colnames(input_speciesprofiles))
colnames(input_descriptions) <- paste0("input_", colnames(input_descriptions))
```

## Preview data

1. Number of rows:

* Taxa: `r nrow(input_taxa)`
* Distributions: `r nrow(input_distributions)`
* Species profiles: `r nrow(input_speciesprofiles)`
* Descriptions: `r nrow(input_descriptions)`

2. Number of taxa per kingdom and rank:

```{r echo = FALSE}
input_taxa %>%
  group_by(input_kingdom, input_rank) %>%
  summarize(
    `taxa` = n()
  ) %>%
  adorn_totals("row")
```

3. Number of taxa and descriptions per type:

```{r echo = FALSE}
input_descriptions %>%
  group_by(input_type) %>%
  summarize(
    `taxa` = n(),
    `unique taxa` = n_distinct(input_verificationKey),
    `unique descriptions` = n_distinct(input_description)
  ) %>%
  adorn_totals("row")
```

## Taxon core {#taxon-core}

### Pre-processing

1. Create a dataframe from the source taxa:

```{r}
taxon <- input_taxa
```

2. Separate `input_canonicalName` in 3 parts:

```{r}
taxon %<>% separate(
  input_canonicalName,
  into = c(
    "input_canonicalName_genus",
    "input_canonicalName_species",
    "input_canonicalName_infraspecific"
  ),
  sep = "\\s+",
  remove = FALSE,
  convert = TRUE,
  extra = "drop",
  fill = "right"
)
```

### Term mapping

Map the data to [Darwin Core Taxon](http://rs.gbif.org/core/dwc_taxon_2015-04-24.xml).

#### language

```{r}
taxon %<>% mutate(language = "en")
```

#### license

The license under which the unified checklist will be published equals the least open license of the source checklists. In the TrIAS project, the source checklists may be published under the following licenses, ranked from most open (1) to more restricive (3):

```{r}
legal_licenses <- tibble::tibble(
  license = c(
    "http://creativecommons.org/publicdomain/zero/1.0/legalcode",
    "http://creativecommons.org/licenses/by/4.0/legalcode",
    "https://creativecommons.org/licenses/by-nc/4.0/legalcode"
    ),
  ranking = c(1:3)
)
legal_licenses
```

Extract all unique licenses from the source checklists:

```{r}
checklists_licenses <- checklists %>% distinct(license)
checklists_licenses
```

We need to take the license of the [gbif backbone taxonomy](https://www.gbif.org/dataset/d7dddbf4-2cf0-4f39-9b2a-bb099caae36c) into consideration as well, which is a CC-BY license:

```{r}
checklists_licenses %<>% add_row(license = "http://creativecommons.org/licenses/by/4.0/legalcode")
```

We add the ranking from `legal_licenses` to the checklist licenses and extract the most restrictive one by filtering on the highest ranking:

```{r}
most_restrictive_license <- checklists_licenses %>% 
  left_join(legal_licenses, by = "license") %>% 
  filter(ranking == max(ranking)) %>% 
  select(license)
most_restrictive_license
```

We add this to the taxon core:

```{r}
taxon %<>% mutate(license = sQuote(most_restrictive_license))
```

#### rightsHolder

We do not set `rightsHolder` as the taxon and its related information is based on different source checklists (which in turn are based on other sources), published by different organizations, and mostly released under CC0. We make effort to credit the source in `references` (taxon core) and `source` (in the extensions).

```{r}
taxon %<>% mutate(rightsHolder = NA)
```

#### bibliographicCitation

```{r}
#include?
```

#### datasetID

```{r}
taxon %<>% mutate(datasetID = "")
```

#### institutionCode

```{r}
taxon %<>% mutate(institutionCode = "ISSG")
```

#### datasetName

```{r}
taxon %<>% mutate(datasetName = "Unified checklist of alien species in Belgium")
```

#### references

This is the link to the taxon according to the GBIF backbone taxonomy:

```{r}
taxon %<>% mutate(references = paste0("https://www.gbif.org/species/", input_verificationKey))
```

#### taxonID

```{r}
taxon %<>% mutate(taxonID = paste0("https://www.gbif.org/species/", input_verificationKey))
```

#### scientificName

```{r}
taxon %<>% mutate(scientificName = input_scientificName)
```

#### kingdom

```{r}
taxon %<>% mutate(kingdom = input_kingdom)
```

#### phylum

```{r}
taxon %<>% mutate(phylum = input_phylum)
```

#### class

```{r}
taxon %<>% mutate(phylum = input_class)
```

#### order

```{r}
taxon %<>% mutate(order = input_order)
```

#### family

```{r}
taxon %<>% mutate(family = input_family)
```

#### genus

Inspect differences between `input_genus` and `input_canonicalName_genus`:

```{r}
taxon %>%
  filter(input_genus != input_canonicalName_genus) %>%
  select(input_verificationKey, input_scientificName, input_genus, input_canonicalName_genus, input_taxonomicStatus)
```

The `input_genus` under which the GBIF Backbone Taxonomy has classified a taxon can differ from the genus in the scientific name. Since we consider all our taxa as accepted taxa, we take the genus from the scientific name (= `input_canonicalName_genus`).

```{r}
taxon %<>% mutate(genus = input_canonicalName_genus)
```

#### specificEpithet

```{r}
taxon %<>% mutate(specificEpithet = input_canonicalName_species)
```

#### infraspecificEpithet

```{r}
taxon %<>% mutate(infraspecificEpithet = input_canonicalName_infraspecific)
```

#### taxonRank

Inspect values:

```{r}
taxon %>%
  group_by(input_rank) %>%
  count()
```

Map values to lowercase:

```{r}
taxon %<>% mutate(taxonRank = str_to_lower(input_rank))
```

#### scientificNameAuthorship

```{r}
taxon %<>% mutate(scientificNameAuthorship = input_authorship)
```

#### taxonRemarks

Here, we integrate the reference (doi) of the *source* of the taxon information (contained in `input_sourceChecklists`), i.e. the link to the specific taxon in the specific checklist(s).

`input_sourceChecklist` now integrates all datasetKeys of the source checklists that include the specific taxon, separated by a comma. We need to split these keys and transform `taxon` such that one row contains only one sourceChecklist per taxon:

```{r}
# Split `input_sourceChecklist` based on ",". The maximal amount of generated columns equals the total amount of source checklists in `checklists:

taxon %<>% separate(input_sourceChecklists, 
                    into = c(paste("source", 1:nrow(checklists), sep = "_")), 
                    sep =",", 
                    fill = "right") 

# Create `taxon` with one row containing only one sourceChecklist per taxon:

taxon %<>% gather(
  key = source, 
  value = key,
  paste("source", 1:nrow(checklists), sep = "_"),
  na.rm = TRUE, 
  convert = FALSE)

# Order by `input_verificationKey`:

taxon %<>% arrange(input_verificationKey)
```
  
Next, We combine the datasetKeys of the original sources with their respective doi's using the dataframe `checklists`:

```{r}
taxon %<>% left_join(
  select(checklists, datasetKey, doi),
  by = c("key" = "datasetKey"))
```

Then, we transform `taxon` to wide dataset again, with all information for one taxon bundled in one row and one doi per column:

```{r}
# First remove column `key`:
taxon %<>% select(-key)

# Transform taxon to wide dataset, with one column containing only one doi (column name starting with `source_`):
taxon %<>% spread(source, doi)
```

Generate `taxonRemarks` by combining information in the `source_` columns:

```{r}
# Combine source information in one column:
taxon %<>% unite(col = "source", starts_with("source_"), sep = ",")

# Delete "NA":
taxon %<>% mutate(source = str_remove_all(source,"(,NA)"))

# Add prefix "Sources considered for unifying information: "
taxon %<>% mutate(taxonRemarks = paste("Sources considered for unifying information:", source, sep = " "))
```

### Post-processing

Remove the original columns:

```{r}
taxon %<>% select(-starts_with("input_"), -source)
```

Preview data:

```{r}
taxon %>% head()
```

Save to CSV:

```{r}
write_csv(taxon, here("data", "processed", "taxon.csv"), na = "")
```

# Create source citation function

Each piece of information in the distribution, species profile or description extension will be documented with the specific source. This source is the full reference to the taxon as it is published in the source checklist on GBIF For instance, the full reference to the **distribution** of _Nymphea marliacea Marliac_ according to the Manual of alien plants is:

> https://www.gbif.org/species/141264581: Nymphaea marliacea Marliac in Verloove F, Groom Q, Brosens D, Desmet P, Reyserhove L (2018). Manual of the Alien Plants of Belgium. Version 1.7. Botanic Garden Meise. Checklist dataset https://doi.org/10.15468/wtda1m. 

This information is a combination of: 

- `input_taxonKey`: e.g. `1412645812` (contained in `input_distributions.csv`),
- `input_schientificName`: e.g. `Nymphaea marliacea Marliac` (contained in `input_distributions.csv`),
- `citation`: e.g. `Verloove F, Groom Q, Brosens D, Desmet P, Reyserhove L (2018). Manual of the Alien Plants of Belgium. Version 1.7. Botanic Garden Meise. Checklist dataset https://doi.org/10.15468/wtda1m.` (contained in `checklist.csv`)

To generate this full references, we need to (1) join two datasets and (2) paste the required information together in one field `source`. This process will be repeated three times (one time for each extension). To make the generation of this full reference repeatable, we here build a function `build_source_citation()`.

```{r}
build_source_citation <- function(extension, checklists){
  
  # Join the extension and citation by their datasetKey:
  
  extension <-
    extension %>% 
    left_join(
      select(checklists, datasetKey, citation),
      by = setNames("datasetKey", "input_datasetKey")
    ) 
  
  # Generate the field `source` by combining `taxonKey`, `scientificName` and `citation`. 
  
    extension %>% 
    mutate(source = paste0(
      "https://www.gbif.org/species/",
      input_taxonKey,
      ": ",
      input_scientificName,
      " in ",
      citation,
      sep = " "
    )) %>% 
    select(-citation)           # Remove citation from the dataframe
    }
```

## Distribution extension {#distribution-extension}

### Pre-processing

Create a dataframe with all data:

```{r}
distribution <- input_distributions
```

Map the data to [Species Distribution](http://rs.gbif.org/extension/gbif/1.0/distribution.xml).

### Term mapping

#### taxonID

```{r}
distribution %<>% mutate(taxonID = paste0("https://www.gbif.org/species/", input_verificationKey))
```

#### locationID

```{r}
distribution %<>% mutate(locationID = "ISO_3166-2:BE") 
```

#### locality

```{r}
distribution %<>% mutate(locatlity = "Belgium") 
```

#### countryCode

```{r}
distribution %<>% mutate(countryCode = "BE") 
```

#### occurrenceStatus

```{r}
distribution %<>% mutate(occurrenceStatus = "present") 
```

#### establishmentMeans

```{r}
distribution %<>% mutate(establishmentMeans = "introduced") 
```

#### eventDate 

The distribution information applies to a certain date range, which we will express here as an ISO 8601 date `yyyy/yyyy` (`input_startYear/input_endYear`). How the information for `input_startYear` and `input_endYear` is extracted from the source checklists, is described [here](https://trias-project.github.io/unified-checklist/unify_information.html#unify-distribution). As a result, each taxon in `input_distribution` has *or* an `input_startYear` and an `input_endYear` *or* no eventDate information at all.

```{r}
distribution  %<>% mutate(eventDate = case_when(
  is.na(input_startYear) & is.na(input_endYear) ~ "",
  TRUE ~ paste(input_startYear, input_endYear, sep = "/")))
``` 
 
#### source

```{r}
distribution <- build_source_citation(distribution, checklists)
```

### Post-processing

Remove the original columns:

```{r}
distribution %<>% select(-starts_with("input_"))
```

Preview data:

```{r}
distribution %>% head()
```

Save to CSV:

```{r}
write_csv(distribution, here("data", "processed", "distribution.csv"), na = "")
```

## Description extension {#description-extension}

### Pre-processing

```{r}
description <- input_descriptions
```

Map the data to [Taxon Description](http://rs.gbif.org/extension/gbif/1.0/description.xml).

### Term mapping

#### taxonID

```{r}
description %<>% mutate(taxonID = paste0("https://www.gbif.org/species/", input_verificationKey)) 
```

#### description

```{r}
description %<>% mutate(description = input_description)
```

#### type

```{r}
description %<>% mutate(type = input_type)
```

#### language

```{r}
description %<>% mutate(language = "en")
```

#### source

```{r}
description <- build_source_citation(description, checklists)
```

### Post-processing

Remove the original columns:

```{r}
description %<>% select(-starts_with("input_"))
```

Preview data:

```{r}
description %>% head()
```

Save to CSV:

```{r}
write_csv(description, here("data", "processed", "description.csv"), na = "")
```

## Species profile extension {#species-profile-extension}

In this extension will express broad habitat characteristics of the species.

```{r}
species_profile <- input_speciesprofiles
```

### Term mapping

Map the data to [Species Profile](http://rs.gbif.org/extension/gbif/1.0/speciesprofile.xml).

#### taxonID

```{r}
species_profile %<>% mutate(taxonID = paste0("https://www.gbif.org/species/", input_verificationKey))
```

#### isMarine

```{r}
species_profile %<>% mutate(isMarine = input_marine)
```

#### isFreshwater

```{r}
species_profile %<>% mutate(isFreshwater = input_freshwater)
```

#### isTerrestrial

```{r}
species_profile %<>% mutate(isTerrestrial = input_terrestrial)
```

#### source

```{r}
species_profile <- build_source_citation(species_profile, checklists)
```

#### habitat

`habitat` summarizes all information contained in `isMarine`, `isFreshwater` and `isTerrestrial`. 

```{r}
species_profile %>% 
  group_by(isMarine, isFreshwater, isTerrestrial) %>% 
  summarize(records = n()) %>% 
  arrange(isMarine, isFreshwater, isTerrestrial)
```

Map `habitat`:

```{r}
species_profile %<>% mutate(habitat = case_when(
  isMarine == "FALSE" & isFreshwater == "FALSE" & isTerrestrial == "TRUE"  ~ "terrestrial",
  isMarine == "FALSE" & isFreshwater == "TRUE"  & isTerrestrial == "FALSE" ~ "freshwater",
  isMarine == "FALSE" & isFreshwater == "TRUE"  & isTerrestrial == "TRUE"  ~ "freshwater|terrestrial",
  isMarine == "TRUE"  & isFreshwater == "FALSE" & isTerrestrial == "FALSE" ~ "marine",
  isMarine == "TRUE"  & isFreshwater == "FALSE" & isTerrestrial == "TRUE"  ~ "marine|terrestrial",
  isMarine == "TRUE"  & isFreshwater == "TRUE"  & isTerrestrial == "FALSE" ~ "marine|freshwater",
  isMarine == "TRUE"  & isFreshwater == "TRUE"  & isTerrestrial == "TRUE"  ~ "marine|freshwater|terrestrial"
))
```

Show mapping:

```{r}
species_profile %>% 
  group_by(isMarine, isFreshwater, isTerrestrial, habitat) %>% 
  summarize(records = n()) 
```

### Post-processing

Remove the original columns:

```{r}
species_profile %<>% select(-starts_with("input_"))
```

Sort on `taxonID`:

```{r}
species_profile %<>% arrange(taxonID)
```

Preview data:

```{r}
species_profile %>% head()
```

Save to CSV:

```{r}
write.csv(species_profile, here("data", "processed", "speciesprofile.csv"), na = "")
```
