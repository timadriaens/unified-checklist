---
title: "Get taxa from checklists"
author:
- Peter Desmet
- Damiano Oldoni
date: "`r Sys.Date()`"
output:
  html_document:
    df_print: paged
    number_sections: true
    toc: true
    toc_depth: 3
    toc_float: true
---

In this document we choose species checklists and download and filter the taxa they contain.

```{r setup, include = FALSE}
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE)
```

Load libraries:

```{r}
library(tidyverse)      # To do data science
library(magrittr)       # To use %<>% pipes
library(here)           # To find files
library(janitor)        # To clean input data
library(digest)         # To generate hashes
library(rgbif)          # To use GBIF services
library(trias)          # To use functions developed for TrIAS
```

# Choose checklists

The unified checklist is compiled from [species checklists published to GBIF under the TrIAS project](https://www.gbif.org/dataset/search?type=CHECKLIST&project_id=trias). Here we choose the checklists we want to include and rank them by trust (most trustworthy first). The ranking will help to choose between duplicate taxa in later steps.

Choose checklists:

```{r choose_checklists}
checklist_keys <- c(
  "9ff7d317-609b-4c08-bd86-3bc404b77c42", # alien-plants-belgium
  "289244ee-e1c1-49aa-b2d7-d379391ce265", # alien-macroinvertebrates
  "98940a79-2bf1-46e6-afd6-ba2e85a26f9f"  # alien-fished-checklist
# "b043c480-dd36-4f4f-aa82-e188753ff09d", # uredinales-belgium-checklist
# "1f3505cd-5d98-4e23-bd3b-ffe59d05d7c2", # ad-hoc-checklist
# "1738f272-6b5d-4f43-9a92-453a8c5ea50a", # rinse-pathways-checklist
# "3f5e930b-52a5-461d-87ec-26ecd66f14a3"  # rinse-registry-checklist
)
```

Get metadata for these checklists from GBIF:

```{r get_checklist_metadata_from_gbif}
checklists <- map(checklist_keys, function(x) rgbif::datasets(uuid = x))

# Create dataframe with core information
checklists <- checklists %>% map_dfr(function(x) list(
  datasetKey = x$data$key,
  title = x$data$title,
  modified = x$data$modified,
  publisher = x$data$publishingOrganizationKey,
  doi = x$data$doi)
)
```

Preview metadata to ensure we have the correct checklists:

```{r preview_metadata}
checklists
```

Save to CSV:

```{r save_checklist_metadata}
write_csv(checklists, here("data", "interim", "checklists.csv"), na = "")
```

# Get taxa

Get taxa from these checklists from GBIF.

**Note**: here we get _checklist taxa_, not _GBIF backbone taxa_.

```{r get_taxa_from_gbif}
checklist_taxa <- rgbif::name_lookup(
  datasetKey = checklists$datasetKey,
  origin = "source", # Only source taxa, not denormed higher classification taxa
  limit = 99999, # Should be more than total taxa for all checklists
  return = "data"
)
```

Select columns of interest and sort by taxon `key`:

```{r select_columns}
checklist_taxa <- checklist_taxa %>%
  select(key, scientificName, datasetKey, nubKey) %>%
  arrange(key)
```

Rename columns:

```{r rename_columns}
checklist_taxa <- checklist_taxa %>% rename(
  checklist_taxonKey = key,
  checklist_scientificName = scientificName,
  checklist_datasetKey = datasetKey
)
```

Preview checklist taxa:

```{r preview_taxa}
head(checklist_taxa)
```

# Filter on distribution

Our checklists might contain more than alien species in Belgium. We therefore use the `trias::has_distribution()` function to filter on the [distribution](http://rs.gbif.org/extension/gbif/1.0/distribution.xml) information.

We will filter on:

1. [invasion stage](http://gbif.github.io/parsers/apidocs/org/gbif/api/vocabulary/EstablishmentMeans.html): `establishmentMeans` equal to one of `INTRODUCED`,  `NATURALISED`, `INVASIVE`, `ASSISTED COLONISATION`
2. [presence status](https://gbif.github.io/gbif-api/apidocs/org/gbif/api/vocabulary/OccurrenceStatus.html): `status` equal to one of `PRESENT`, `COMMMON`, `RARE`, `IRREGULAR`
3. presence in Belgium (`country` equal to `BE`)

**Note**: we filter on distribution information of our _checklist taxa_, not backbone taxa. That is because backbone taxa contain distribution information from our own checklists _and_ other checklists, which we don't want to consider here.

E.g. compare:

* Distributions for _checklist_ taxon [Eriocheir sinensis](https://api.gbif.org/v1/species/140563012/distributions) (`140563012`)
* Distributions for _backbone_ taxon [Eriocheir sinensis](https://api.gbif.org/v1/species/2225776/distributions) (`2225776`)

Get distribution for all taxa and append `TRUE`/`FALSE` result as extra column. This step can take long.

```{r check_distributions_on_gbif}
progress_bar <- progress_estimated(nrow(checklist_taxa))
checklist_taxa <- checklist_taxa %>%
  mutate(valid_distribution = map_lgl(
    checklist_taxa$key, ~ {
    progress_bar$tick()$print()
    trias::gbif_has_distribution(
      taxon_key = .,
      country = "BE",
      establishmentMeans = c("INTRODUCED", "NATURALISED", 
                             "INVASIVE", "ASSISTED COLONISATION"),
      status = c("PRESENT", "COMMMON", "RARE", "IRREGULAR"))
    }))
```

Preview results:

```{r preview_has_distribution}
checklist_taxa %>%
  select(key, scientificName, valid_distribution) %>%
  head(20)
```

Show some stats:

```{r show_distribution_stats_per_checklist}
checklist_taxa %>%
  group_by(datasetKey) %>%
  summarize(
    taxa = n(),
    taxa_with_valid_distribution = sum(valid_distribution),
    taxa_without_valid_distribution = sum(!valid_distribution)
  )
```

Only keep taxa with valid distribution:

```{r keep_valid_distribution}
checklist_taxa <- checklist_taxa %>%
  filter(valid_distribution == TRUE) %>%
  select(-valid_distribution)
```

Total number of taxa with valid distributions:

```{r show_total_valid_distribution_taxa}
nrow(checklist_taxa)
```

# Get backbone info

To make decisions regarding synonyms and higher classification, we need to retrieve GBIF backbone information, if present:


```{r retrieve_taxonomic_info_backbone}
taxon <- checklist_taxa %>% filter(is.finite(nubKey))
nub_keys <- checklist_taxa %>% 
  filter(is.finite(nubKey)) %>% 
  distinct(nubKey)
progress_bar <- progress_estimated(nrow(nub_keys))
taxon_backbone_info <-  map_dfr(nub_keys$nubKey, ~ {
  progress_bar$tick()$print()
  rgbif::name_usage(key = ., return = "data")
  })
```

We select taxonomic information we are interested to:

```{r select_cols_backbone}
taxon_info <- c("key", "scientificName", "species", "genus", "family", "order",
                "class", "phylum", "kingdom",
                "rank", "speciesKey", "taxonomicStatus", 
                "acceptedKey", "accepted", "issues")

taxon_backbone_info <- taxon_backbone_info %>%
  select(one_of(taxon_info))
```

In case some information misses, add empty column(s):

```{r}
cols_to_add <- taxon_info[!which(taxon_info %in% 
           colnames(taxon_backbone_info))]

taxon_backbone_info <- map(cols_to_add, 
                           function(x) taxon_backbone_info %>% 
                             mutate(!! sym(x) := NA)) %>% 
  reduce(full_join, .init = taxon_backbone_info)
```

Next, we unlist column `issues` and we separate them by comma (if multiple issues are present):

```{r unlist_issues}
taxon_backbone_info <- taxon_backbone_info %>%
  group_by_at(vars(-issues)) %>%
  summarize(issues = str_c(issues, collapse = ",")) %>%
  ungroup() %>%
  mutate(issues = ifelse(
    issues != "NULL",
    issues,
    NA
  ))
```

All possible combinations of GBIF backbone issues present in our data frame:

```{r preview issues}
taxon_backbone_info %>% distinct(issues)
```

For improving readibility we rename the column `accepted` to `acceptedName` and add prefix `backbone_` or `checklist_` to all columns containing information from GBIF backbone or checklist respectively:

```{r add_prefix_backbone}
taxon_backbone_info <- taxon_backbone_info %>% rename(acceptedName = accepted)
colnames(taxon_backbone_info) <- paste0("backbone_", 
                                        colnames(taxon_backbone_info))
colnames(checklist_taxa) <- paste0("checklist_", 
                                        colnames(checklist_taxa))
```

We merge the information from checklists and GBIF backbone:

```{r}
combined_taxon_info <- checklist_taxa %>%
  left_join(taxon_backbone_info, 
            by = c("checklist_nubKey" = "backbone_key"))
```

For readibility we rename `checklist_nubKey` (tendency of GBIF to deprecate the word _nubKey_) to `backbone_taxonKey`.

```{r checklist_nubKey_to_backbone_taxonKey}
combined_taxon_info <- combined_taxon_info %>%
  rename(backbone_taxonKey = checklist_nubKey)
```

Preview:

```{r preview_merged_final}
combined_taxon_info %>% head()
```

# Save output

Save the taxonomic information to a tsv file:

```{r}
write_tsv(combined_taxon_info, path = taxa_output_file, na = "")
```
