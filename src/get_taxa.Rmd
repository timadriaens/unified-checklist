---
title: "Get taxa from checklists"
author:
- Peter Desmet
- Damiano Oldoni
date: "`r Sys.Date()`"
output:
  html_document:
    df_print: paged
    number_sections: true
    toc: true
    toc_depth: 3
    toc_float: true
---

In this document we choose species checklists and download and filter the taxa they contain.

```{r setup, include = FALSE}
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE)
```

Load libraries:

```{r}
library(tidyverse)      # To do data science
library(magrittr)       # To use %<>% pipes
library(here)           # To find files
library(janitor)        # To clean input data
library(digest)         # To generate hashes
library(rgbif)          # To use GBIF services
library(trias)          # To use functions developed for TrIAS
```

# Choose checklists

The unified checklist is compiled from [species checklists published to GBIF under the TrIAS project](https://www.gbif.org/dataset/search?type=CHECKLIST&project_id=trias). Here we choose the checklists we want to include and rank them by trust (most trustworthy first). The ranking will help to choose between duplicate taxa in later steps.

Choose checklists:

```{r}
checklist_keys <- c(
  "9ff7d317-609b-4c08-bd86-3bc404b77c42", # alien-plants-belgium
  "289244ee-e1c1-49aa-b2d7-d379391ce265", # alien-macroinvertebrates
  "98940a79-2bf1-46e6-afd6-ba2e85a26f9f"  # alien-fished-checklist
# "b043c480-dd36-4f4f-aa82-e188753ff09d", # uredinales-belgium-checklist
# "1f3505cd-5d98-4e23-bd3b-ffe59d05d7c2", # ad-hoc-checklist
# "1738f272-6b5d-4f43-9a92-453a8c5ea50a", # rinse-pathways-checklist
# "3f5e930b-52a5-461d-87ec-26ecd66f14a3"  # rinse-registry-checklist
)
```

Get metadata for these checklists from GBIF:

```{r get_checklist_metadata_from_gbif}
checklists <- map(checklist_keys, function(x) rgbif::datasets(uuid = x))

# Create dataframe with core information
checklists <- checklists %>% map_dfr(function(x) list(
  datasetKey = x$data$key,
  title = x$data$title,
  modified = x$data$modified,
  publisher = x$data$publishingOrganizationKey,
  doi = x$data$doi)
)
```

Show metadata to ensure we have the correct checklists:

```{r}
checklists
```

Save to CSV:

```{r}
write_csv(checklists, here("data", "interim", "checklists.csv"), na = "")
```

# Get taxa

Get taxa from these checklists from GBIF.

**Note**: here we get _checklist taxa_, not _GBIF backbone taxa_. To return _issues_ for the taxa, we also need to use `name_usage()` rather than `name_lookup()`.

```{r get_checklist_taxa_from_gbif}
checklist_taxa <- map_df(checklists$datasetKey, function(x) 
  name_usage(
    datasetKey = x,
    limit = 99999, # Should be more than total taxa for all checklists
    return = "data"
  )) %>% 
  filter(origin == "SOURCE") # Keep only source taxa, not denormed higher classification taxa
```

Select columns of interest and sort by taxon `key`:

```{r}
checklist_taxa <- checklist_taxa %>%
  select(key, scientificName, datasetKey, taxonID, nameType, issues, nubKey) %>%
  arrange(key)
```

Convert the column `issues` from a list to a concatenated string:

```{r}
checklist_taxa <- checklist_taxa %>%
  group_by_at(vars(-issues)) %>%
  summarize(issues = str_c(issues, collapse = ",")) %>%
  ungroup() %>%
  mutate(
    issues = na_if(issues, "NULL"),
    issues = na_if(issues, "NA")
  )
```

Preview checklist taxa:

```{r}
head(checklist_taxa)
```

# Filter on distribution

TrIAS checklists can contain more than alien species in Belgium. We therefore need to filter on the associated [distribution](http://rs.gbif.org/extension/gbif/1.0/distribution.xml) information (using the `trias::has_distribution()` function) as follows:

1. **In Belgium**: `country`(code) = `BE`
2. **Present**: [`occurrenceStatus` status](https://gbif.github.io/gbif-api/apidocs/org/gbif/api/vocabulary/OccurrenceStatus.html) = `PRESENT`, `COMMMON`, `RARE` OR `IRREGULAR`
2. **Introduced**: [`establishmentMeans`](http://gbif.github.io/parsers/apidocs/org/gbif/api/vocabulary/EstablishmentMeans.html) = `INTRODUCED`,  `NATURALISED`, `INVASIVE` OR `ASSISTED COLONISATION`

**Note**: we filter on distribution information of _checklist taxa_, not _GBIF backbone taxa**. That is because backbone taxa contain distribution information from TrIAS checklists _and_ other checklists, which we don't want to consider here.

E.g. compare:

* Distributions for _checklist_ taxon [Eriocheir sinensis](https://api.gbif.org/v1/species/140563012/distributions) (`140563012`)
* Distributions for _backbone_ taxon [Eriocheir sinensis](https://api.gbif.org/v1/species/2225776/distributions) (`2225776`)

Get distribution information from GBIF and check if these meet the filter criteria. The result (`TRUE`/`FALSE`) is inserted as an extra column `valid_distribution`:

```{r get_distribution_info_from_gbif}
progress_bar <- progress_estimated(nrow(checklist_taxa))

checklist_taxa <- checklist_taxa %>% mutate(valid_distribution = map_lgl(
  checklist_taxa$key, function(x) {
    progress_bar$tick()$print()
    trias::gbif_has_distribution(
      taxon_key = x,
      country = "BE",
      establishmentMeans = c(
        "INTRODUCED",
        "NATURALISED", 
        "INVASIVE",
        "ASSISTED COLONISATION"
      ),
      status = c(
        "PRESENT",
        "COMMMON",
        "RARE",
        "IRREGULAR"
      )
    )
  }
))
```

Preview some taxa with not a single valid distribution (key can be used to verify manually on GBIF):

```{r}
checklist_taxa %>%
  filter(!valid_distribution) %>%
  head()
```

Rename `nubKey` to `bb_key` and move to the end:

```{r}
checklist_taxa <- checklist_taxa %>%
  rename(bb_key = nubKey)
  select(-bb_key, everything())
```

# Get GBIF taxonomy backbone information

A taxon can occur on more than one checklist. To identify these duplicates, we cannot rely on the _scientific name_ as there might be spelling variations (e.g. with or without authorship) and it does not account for synonyms that should be lumped with the accepted taxon. To have **unifying taxon identifiers across taxa**, we rely on the [GBIF backbone taxonomy](https://doi.org/10.15468/39omei), to which every checklist taxon (re)published to GBIF is automatically matched. If a match in the backbone is found, the checklist taxon will have a `nubKey`.

Filter taxa on having valid distribution and `nubKey` and create vector of unique `nubKey`s:

```{r}
nub_keys <- checklist_taxa %>%
  filter(valid_distribution) %>%
  filter(is.finite(bb_key)) %>%
  select(bb_key) %>%
  distinct(bb_key) %>%
  pull()
```

Get GBIF backbone taxonomy information:

```{r get_backbone_info_from_gbif}
progress_bar <- progress_estimated(length(nub_keys))

backbone_info <- map_dfr(nub_keys, function(x) {
    progress_bar$tick()$print()
    rgbif::name_usage(
      key = x,
      return = "data"
    )
  }
)
```

Select columns of interest:

```{r}
backbone_info <- backbone_info %>% select(
  "key", "scientificName", "species", "genus", "family", "order", "class",
  "phylum", "kingdom", "rank", "speciesKey", "taxonomicStatus", "acceptedKey", 
  "accepted"
)
```

Rename `accepted` to `acceptedName`:

```{r}
backbone_info <- backbone_info %>% rename(acceptedName = accepted)
```

Add prefix `bb_` to column names:

```{r}
colnames(backbone_info) <- paste0("bb_", colnames(backbone_info))
```

Merge backbone information with checklist taxa:

```{r}
checklist_taxa <- checklist_taxa %>% left_join(
  backbone_info, 
  by = "bb_key"
)
```

Preview merged information:

```{r}
checklist_taxa %>% head()
```

Show summary per checklist:

```{r}
checklist_taxa %>%
  group_by(datasetKey) %>%
  summarize(
    taxa = n(),
    in_backbone_and_distribution = sum(valid_distribution & !is.na(bb_key)),
    outside_distribution = sum(!valid_distribution),
    outside_backbone = sum(valid_distribution & is.na(bb_key))
  ) %>%
  adorn_totals("row")
```

# Save data

Save to CSV:

```{r}
write_csv(checklist_taxa, here("data", "interim", "checklist_taxa.csv"), na = "")
```
