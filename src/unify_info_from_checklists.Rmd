---
title: "Unify relevant information from checklists"
author:
- Damiano Oldoni
- Peter Desmet
date: "`r Sys.Date()`"
output:
  html_document:
    toc: true
    toc_depth: 3
    toc_float: true
    number_sections: true
knit: (function(input_file, encoding) { rmarkdown::render(input_file, encoding = encoding, output_file = paste0("../docs/",sub(".Rmd", ".html", basename(input_file))))})
---

This document describes how to retrieve all relevant information from the checklists and perform some cleaning.

# Setup

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE)
```

Load libraries:

```{r load_libraries}
# Tidyverse packages
library(tidyr)
library(dplyr)
library(purrr)
library(stringr)
library(readr)
# GBIF related packages
library(rgbif)
# project package
library(trias)
```

# Get data

## Get taxa

We load taxa information as previously wrangled in pipeline `verify_synonyms.Rmd`.

```{r load_taxa_with_verification_key}
taxa_verified <- read_tsv("../data/interim/taxa_after_verification.tsv")
```

Preview:

```{r preview}
taxa_verified %>% head(n = 10)
```

Taxa with a verification key:

```{r show_count_vk}
taxa_verified %>% 
  count(has_verification_key = !is.na(verification_key))
```

## Load checklists metadata

Set file path:

```{r input_file_path}
checklist_metadata_file <- "../data/output/checklist_metadata.tsv"
```

Load checklist metadata (ranked by trust):

```{r load_checklist_metadata}
checklist_metadata <- read_tsv(checklist_metadata_file)
checklist_metadata
```

# Retrieve relevant information related to taxa

## Find duplicates verification key

By assigning verification keys to unmatched taxa and synonyms some duplicates will likely appear:

```{r get_unique_vk}
vks <- taxa_verified %>%
  filter(!is.na(verification_key)) %>%
  pull(verification_key)
vks_duplicates <- vks[duplicated(vks)]
taxa_vks_duplicates <- taxa_verified %>% 
  filter(verification_key %in% vks_duplicates)
taxa_vks_duplicates
```

We extract the checklist taxon keys related to these verification keys:

```{r extract_checklist_taxon_keys}
checklist_keys <- taxa_verified %>%
  filter(!is.na(verification_key)) %>%
  pull(checklist_key)
```

## Taxonomic information

We will now retrieve from GBIF Backbone the taxonomic information related to unique verification keys:

```{r extract_taxonomic_information}
vks <- vks[!duplicated(vks)]
names(vks) <- vks # check! is it needed?
progress_bar <- progress_estimated(length(vks))
taxon_backbone_info <-  map_dfr(vks, ~ {
  progress_bar$tick()$print()
  rgbif::name_usage(key = ., return = "data")
  })
```

## Distribution

Extract distribution information from checklists

```{r retrieve_distribution_information}
progress_bar <- progress_estimated(length(checklist_keys))
distribution <-  map_dfr(checklist_keys, ~ {
  progress_bar$tick()$print()
  rgbif::name_usage(key = ., return = "data",
                    data = "distribution")
  })
# distribution <- distribution %>% select(-source)
```

Preview:

```{r preview_distribution}
distribution %>% head(n = 10)
```

## Filter alien species by distribution

Filter distributions by:

1. invasion stage (`establishmentMeans` equal to one of `INTRODUCED`,  `NATURALISED`, `INVASIVE`, `ASSISTED COLONISATION`) see GitHub issue [#28](https://github.com/trias-project/pipeline/issues/28#issuecomment-382036510)
2. presence status (`status` not equal to `DOUBTFUL`, `ABSENT`, `EXCLUDED` or `EXTINCT`) see GitHugb issue [#26](https://github.com/trias-project/pipeline/issues/26#issuecomment-382036007)
3. presence in Belgium (`country` equal to `BE`)

```{r filter_by_establishmentMeans}
distribution <- distribution %>%
  filter(establishmentMeans %in% c("INTRODUCED", "NATURALISED", "INVASIVE",
                                   "ASSISTED COLONISATION"),
         !status %in% c("DOUBTFUL", "ABSENT", "EXCLUDED", "EXTINCT"),
         country == "BE")
```

Taxa left:

```{r show_effect_filtering}
checklist_keys <- unique(distribution$taxonKey)
taxa_verified <- taxa_verified %>%
  filter(checklist_key %in% checklist_keys)
verification_keys <- unique(taxa_verified$verification_key)
```

## Description

Extract description information

```{r retrieve_description_information}
progress_bar <- progress_estimated(length(checklist_keys))
description <-  map_dfr(checklist_keys, ~ {
  progress_bar$tick()$print()
  rgbif::name_usage(key = ., return = "data",
                    data = "description")
  })
# description <- description %>% select(-c(key, language, source))
```

Preview:

```{r preview_description}
description %>% head(n = 10)
```

## Species profile

Extract species profile:

```{r retrieve_species_profile_information}
progress_bar <- progress_estimated(length(checklist_keys))
species_profiles <-  map_dfr(checklist_keys, ~ {
  progress_bar$tick()$print()
  rgbif::name_usage(key = ., return = "data",
                    data = "speciesProfiles")
  })
```

Preview:

```{r preview_species_profiles}
species_profiles %>% head(n = 10)
```

# Tidy data

## Tidy description extension

Contrarily to distribution and species profile, description extension contains a column `type` with the following descriptors: 

```{r descriptors}
description %>% distinct(type)
descriptors <- description %>% distinct(type) %>% pull()
```

while the values of such descriptors are in column `description`.

We need to *tidy* this data.frame in order to have different descriptors as different columns. Unfortunately `dplyr::spread(key, value)` doesn't work due to *duplicates*, i.e. keys with more than one value, for example:

```{r duplicates_issue_spread}
description %>% filter(taxonKey == 141264585 & type == "native range")
```

We use function `trias::spread_with_multiple_values()` from TrIAS package:

```{r tidy_description}
description_tidy <- trias::spread_with_multiple_values(data = description, 
                                                       key = type, 
                                                       value = description)
description_tidy <- description_tidy %>% 
  rename(native_range = `native range`,
         invasion_stage = `invasion stage`)
```

Preview:

```{r preview_tidy_description}
description_tidy %>% head(n = 10)
```

## Split `temporal`

The column `temporal` contains one or two datums:

```{r example_temporal, echo = FALSE}
distribution %>% 
  select(taxonKey, temporal) %>% 
  distinct() %>% 
  filter(!is.na(temporal)) %>%
  head()
```

In case there are two datums, we split them in `first_observed` and `last_observed`. If only a datum is present, then it is used for both  `first_observed`and `last_observed`:

```{r split_temporal}
distribution <- distribution %>% 
  separate(col = temporal,
           sep = "/",
           into = c("first_observed", "last_observed"),
           convert = TRUE,
           fill = "right",
           remove = TRUE) %>%
  mutate(last_observed = ifelse(is.na(last_observed),
                                first_observed,
                                last_observed))
```

As example:

```{r example_split_temporal, echo = FALSE}
distribution %>% 
  filter(locality == "Belgium") %>% 
  select(taxonKey, first_observed, last_observed) %>%
  distinct() %>%
  filter(!is.na(first_observed) & !is.na(last_observed)) %>%
  head()
```

## Split `pathway`

The column `pathway` contains a prefix, `cbd_2014_pathway:` and two different pathway levels divided by symbol `_`

```{r pathway_levels_example, echo = FALSE}
description_tidy %>% 
  distinct(pathway) %>% 
  filter(!is.na(pathway)) %>% 
  head()
```

We split this column in `pathway_level1` and `pathway_level2`

```{r split_pathway}
description_tidy <- description_tidy %>% 
  rowwise() %>%
  mutate(pathway_level1 = 
           str_split_fixed(
             str_split(pathway,
                       pattern = "pathway:")[[1]][2],
             pattern = "_", n = 2)[[1]][1],
         pathway_level2 = 
           str_split_fixed(
             str_split(pathway,pattern = "pathway:")[[1]][2],
             pattern = "_", n = 2)[[2]][1]) %>%
  ungroup() %>%
  select(-pathway) %>%
  mutate(pathway_level1 = na_if(.data$pathway_level1,""),
         pathway_level2 = na_if(.data$pathway_level2,""))
```

As example:

```{r example_split_pathway, echo = FALSE}
description_tidy %>% 
  distinct(pathway_level1, pathway_level2) %>%
  filter(!is.na(pathway_level1) & !is.na(pathway_level2)) %>%
  head()
```

# Couple information to verification key and checklist key

We have to link all retrieved information to verification keys. This is possible by using the link one-to-many between `verification_key` and `checklist_key` in `taxa_verified`:

```{r add_verification_key_to_extensions_info}
# distribution
distribution <- distribution %>% 
  left_join(taxa_verified %>% 
              select(checklist_key, verification_key), 
            by = c("taxonKey" = "checklist_key"))
# descriptions
description_tidy <- description_tidy %>% 
  left_join(taxa_verified %>% 
              select(checklist_key, verification_key), 
            by = c("taxonKey" = "checklist_key"))
#species profile
species_profiles <- species_profiles %>% 
  left_join(taxa_verified %>% 
              select(checklist_key, verification_key), 
            by = c("taxonKey" = "checklist_key"))
```

We need also to link such information to the checklist it comes from by adding column `checklist_datasetKey`:

```{r add_datasetKey_to_extension_dataframes}
# distribution
distribution <- distribution %>%
  left_join(taxa_verified %>%
              select(checklist_key, checklist_datasetKey), 
            by = c("taxonKey" = "checklist_key"))
# descriptions
description_tidy <- description_tidy %>%
  left_join(taxa_verified %>%
              select(checklist_key, checklist_datasetKey), 
            by = c("taxonKey" = "checklist_key"))
# species profile
species_profiles <- species_profiles %>%
  left_join(taxa_verified %>%
              select(checklist_key, checklist_datasetKey), 
            by = c("taxonKey" = "checklist_key"))
```

# Pick distribution

To be able to group distribution information on `verification_key`, decisions need to be taken regarding multiple, possibly conflicting distributions related to the same `verification_key`.

## Get rid of multiple distributions across checklists

We select the first non-NA distribution from most trusted checklist by means of checklist ranking:

```{r filter_by_raking_checklists}
distribution <- distribution %>% 
  rowwise() %>%
  mutate(rank_checklist = 
    which(.data$checklist_datasetKey == checklist_metadata$datasetKey)) %>%
  ungroup() %>%
  group_by(taxonKey) %>%
  filter(rank_checklist == min(rank_checklist)) %>%
  ungroup() %>%
  select(-rank_checklist)
```

## Get rid of multiple localities

Within same checklist pick non-NA distribution from preferred `locality`:

1. Belgium               
2. Flemish Region         
3. Walloon Region 
4. Brussels-Capital Region

```{r ranking_locality}
localities <- distribution %>% 
  distinct(locality) %>%
  pull()
localities
```

Filter by this ranking:

```{r filter_by_ranking_locality}
distribution <- distribution %>% 
  rowwise() %>%
  mutate(rank_locality= 
           which(.data$locality == localities)) %>%
  ungroup() %>%
  group_by(taxonKey) %>%
  filter(rank_locality == min(rank_locality)) %>%
  ungroup() %>%
  select(-rank_locality)
```

## Get one distribution per verification key

Within the same checklist, we might still end up with multiple distributions because multiple taxa are considered to belong to the same verification key:

```{r show_vks_with_multiple_distributions}
distribution %>% 
  group_by(verification_key) %>%
  count() %>%
  arrange(desc(n)) %>%
  filter(n > 1)
```

Pick the earliest non-NA `first_observed` and latest non-NA `last_observed`.

```{r choose_lowest_first_observed_latest_last_observed}
distribution <- distribution %>%
  select(-taxonKey) %>% 
  distinct() %>%
  group_by(verification_key) %>%
  mutate(first_observed = min(first_observed, na.rm = TRUE),
         last_observed = max(last_observed, na.rm = TRUE)) %>%
  ungroup()
distribution %>% head(n = 10)
```

# Pick descriptions

To be able to group description information on verification key, decisions need to be taken regarding multiple, possibly conflicting descriptions related to the same verification key.

## Native range

Pick first non-NA native ranges (plural) from most trusted checklist by means of ranking:

```{r pick_native_range}
native_range_df <- description_tidy %>%
  filter(!is.na(native_range))
native_range_df <- native_range_df %>%
  rowwise() %>%
  mutate(rank_checklist = 
    which(.data$checklist_datasetKey == checklist_metadata$datasetKey)) %>%
  ungroup() %>%
  group_by(verification_key, native_range) %>%
  filter(rank_checklist == min(rank_checklist)) %>%
  ungroup() %>%
  select(-rank_checklist)
```

## Pathways

Pick all non-NA pathways (plural) from checklists.

```{r pick_pathways}
pathways_df <- description_tidy %>%
  filter(!is.na(pathway_level1)) %>% 
  select(-c(key, taxonKey)) %>% 
  distinct()
# add ranking checklists
pathways_df <- pathways_df %>%
  rowwise() %>%
  mutate(rank_checklist = 
           which(.data$checklist_datasetKey == checklist_metadata$datasetKey)) %>%
  ungroup() %>%
  distinct()
# select highest ranked checklists if equal pathways
pathways_df <- pathways_df %>%
  group_by(verification_key, pathway_level1, pathway_level2) %>%
  filter(rank_checklist == min(rank_checklist)) %>%
  ungroup()
# get rid of NA at higher ranked checklist if not NA at lower ranked checklist
pathways_df <- pathways_df %>%
  left_join(pathways_df %>%
              group_by(verification_key, pathway_level1) %>%
              count(), 
            by = c("verification_key", "pathway_level1")) %>%
  filter(n == 1 | !is.na(pathway_level2)) %>%
  select(-c(rank_checklist, n))
```

## Invasion stage

Pick first non-NA invasion stages (plural) from most trusted checklist.

```{r pick_invasion_satge}
invasion_stages_df <- description_tidy %>%
  filter(!is.na(invasion_stage)) %>%
  select(-c(key, taxonKey)) %>% 
  distinct() %>%
  rowwise() %>%
  mutate(rank_checklist = 
           which(.data$checklist_datasetKey == checklist_metadata$datasetKey)) %>%
  ungroup() %>%
  group_by(verification_key, native_range) %>%
  filter(rank_checklist == min(rank_checklist)) %>%
  ungroup() %>%
  select(-rank_checklist)
```

Verification keys could be associated to more than one invasion stage. This is possible due to the fact that multiple taxa can be associated to the same verification key:

```{r show_multiple_invasion_stages}
vks_with_multiple_invasion_stages <- invasion_stages_df %>% 
  group_by(verification_key) %>%
  count() %>%
  filter(n > 1) %>%
  pull(verification_key)
invasion_stages_df %>% 
  filter(verification_key %in% vks_with_multiple_invasion_stages) %>% 
  select(verification_key, invasion_stage, checklist_datasetKey) %>%
  arrange(verification_key)
```

# Pick species profile

To be able to group species profile (i.e. habitat) on verification key, decisions need to be taken regarding multiple, possibly conflicting species profiles related to the same verification key. Some examples:

```{r}
vks_with_multiple_species_profiles <- species_profiles %>% 
  group_by(verification_key) %>%
  count() %>%
  filter(n > 1) %>%
  pull(verification_key)
species_profiles %>% 
  filter(verification_key %in% vks_with_multiple_species_profiles) %>% 
  arrange(verification_key) %>%
  head()
```

We pick the first non-NA species profile from the most trusted checklist. 

```{r pick_species_profile}
species_profiles<- species_profiles %>%
  select(-taxonKey) %>%
  group_by(verification_key) %>% 
  distinct() %>%
  rowwise() %>%
  mutate(rank_checklist = 
           which(.data$checklist_datasetKey == checklist_metadata$datasetKey)) %>%
  ungroup() %>%
  group_by(verification_key) %>%
  filter(rank_checklist == min(rank_checklist)) %>%
  ungroup() %>%
  select(-rank_checklist)
```

We are interested to the fields `marine`, `freshwater`, `terrestrial`:

```{r select_fields_marine_freshwater_terrrestrial}
species_profiles <- species_profiles %>%
  select(verification_key, 
         marine, 
         freshwater, 
         terrestrial, 
         checklist_datasetKey) # do we remove the datasetKey the info comes from?
```

# Standardize vocabularies used in descriptions

Different controlled vocabularies might have been used by the checklists, which are better standardized for the unified checklist.

## Standardize native range

Vocabulary used for native range:

```{r vocabulary_native_range}
native_range_df %>%
  distinct(native_range, checklist_datasetKey) %>%
  mutate(presence = TRUE) %>%
  distinct() %>% 
  spread(checklist_datasetKey, presence)
```

## Standardize pathways

### Standardize pathways at first level

Vocabulary used for first level of pathways:

```{r vocabulary_pathway_level1}
pathways_df %>%
  distinct(pathway_level1, checklist_datasetKey) %>%
  mutate(presence = TRUE) %>%
  distinct() %>% 
  spread(checklist_datasetKey, presence)
``` 

### Standardize pathways at second level

Vocabulary used for second level of pathways:

```{r vocabulary_pathway_level2}
pathways_df %>%
  distinct(pathway_level2, checklist_datasetKey) %>%
  mutate(presence = TRUE) %>%
  distinct() %>% 
  spread(checklist_datasetKey, presence)
``` 

## Standardize invasion stage

Vocabulary used for describing invasion stage:

```{r vocabulary_invasion_stage}
invasion_stages_df %>%
  distinct(invasion_stage, checklist_datasetKey) %>%
  mutate(presence = TRUE) %>%
  distinct() %>% 
  spread(checklist_datasetKey, presence)
```
